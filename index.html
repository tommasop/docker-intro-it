<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Intro to Docker</title>

		<meta name="description" content="Intro to Docker">
		<meta name="author" content="Docker Inc, adapted by John Lewis">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

		<div class="slides">
	
<section>
	<h1>Docker</h1>
	<div>
		<img src="docker-img/docker.png" style="width: 432px; height: 376px; max-height: none; max-width: none;"/>
		<br/>
	</div>
	<div>
    Il contenuto delle slide è liberamente <strike>rubato</strike> <i>ispirato</i> dal materiale di Docker, inc!
		
	</div>
</section>
		
<section>
	<h2>Dalla sua nascita nel Marzo 2013</h2>
	<ul>
		<li class="fragment" data-fragment-index="0">&gt;27.600 commits</li>
		<li class="fragment" data-fragment-index="2">&gt;35.400 github stars</li>
		<li class="fragment" data-fragment-index="3">&gt;1.507 contributors</li>
		<li class="fragment" data-fragment-index="4">&gt;circa mille progetti basati su docker</li>
		<ul>
			<li class="fragment" data-fragment-index="4">UIs, mini-PaaS, Remote Desktop...</li>
		</ul>
		<li class="fragment" data-fragment-index="5">460K applicazioni Dockerizzate, con una crescita del 3100% negli ultimi due anni</li>
		<ul>
			<li class="fragment" data-fragment-index="5">Memcached, Redis, Node.js, Hadoop...</li>
		</ul>
		<li class="fragment" data-fragment-index="6">Integrazione con  Jenkins, Travis, Chef, Puppet, Vagrant and OpenStack</li>
		<li class="fragment" data-fragment-index="7">Centinaia di meetup nel mondo…</li>
		<ul>
			<li class="fragment" data-fragment-index="7">Ebay, Cloudflare, Yandex, and Rackspace utilizzano Docker ogni giorno</li>
		</ul>
	</ul>
</section>

<section>
  <h2>Docker... il cuore</h2>
  <ul>
    <li class="fragment" data-fragment-index="0">Scritto sulla base del container engine di dotCloud</li>
    <ul>
      <li class="fragment" data-fragment-index="0">Versione originale: python</li>
      <li class="fragment" data-fragment-index="0">Versione attuale: C/Go</li>
    </ul>
    <li class="fragment" data-fragment-index="1">Demone Docker in background</li>
    <ul>
      <li class="fragment" data-fragment-index="1">Gestisce container, immagini, build</li>
      <li class="fragment" data-fragment-index="1">HTTP API</li>
      <li class="fragment" data-fragment-index="1">CLI</li>
    </ul>    
    <li class="fragment" data-fragment-index="2">Open Source (GitHub)</li>
  </ul>
</section>   

<section>
	<h2>Il problema:</h2>
	<p>
		<img src="docker-img/the-challenge.png">
	</p>
</section>

<section>
	<h2>Dove lo metto?</h2>
	<p>
		<img src="docker-img/the-matrix-from-hell.png">
	</p>
</section>

<section>
	<h2>Il Trasporto Merci Pre-1960</h2>
	<p>
		<img src="docker-img/cargo-transport-pre-1960.png">
	</p>
</section>

<section>
	<h2>Stessa situazione</h2>
	<p>
		<img src="docker-img/also-a-matrix-from-hell.png">
	</p>
</section>

<section>
	<h2>Un container per domarli ...</h2>
	<p>
		<img src="docker-img/intermodal-shipping-container.png">
	</p>
</section>

<section>
	<h2>Docker è un code-container</h2>
	<p>
		<img src="docker-img/shipping-container-for-code.png">
	</p>
</section>

<section>
	<h2>Elimina il problema alla radice</h2>
	<p>
		<img src="docker-img/eliminates-matrix-from-hell.png">
	</p>
</section>

<section>
	<h2>Prima Reazione</h2>
	<p>
		<img src="docker-img/standards.png">
	</p>
</section>

<section>
	<h2>Un problema</h2>
	
	<pre class="fragment" data-fragment-index="0" style="position:top"><code>Some packages could not be installed. This may mean that you have
requested an impossible situation or if you are using the unstable
distribution that some required packages have not yet been created
or been moved out of Incoming.
The following information may help to resolve the situation:

The following packages have unmet dependencies:
 package1 : Depends: package2 (>= 1.8) but 1.7.5-1ubuntu1 is to be installed
E: Unable to correct problems, you have held broken packages.</code></pre>

	<h2 class="fragment" data-fragment-index="1">La soluzione</h2>
	<pre class="fragment" data-fragment-index="1"><code>sudo add-apt-repository ppa:package2</code></pre>

</section>

<section>

	<h2>Sbagliato!</h2>
	
</section>

<section>
    <h2>Un container per lo sviluppatore</h2>
    <div style="text-align: left;">
        <p>Dentro il container:</p>
        <ul>
            <li class="fragment" data-fragment-index="0">Il mio codice</li>
            <li class="fragment" data-fragment-index="0">Le mie librerie</li>
            <li class="fragment" data-fragment-index="0">Il mio gestore di pacchetti</li>
            <li class="fragment" data-fragment-index="0">La mia applicazione</li>
            <li class="fragment" data-fragment-index="0">I miei dati</li>
        </ul>
    </div>
    
</section>

<section>
	<h2>Lo sviluppatore felice</h2>
	<div style="text-align: left;">
		Build once... (finally) run "anywhere"
		<ul>
			<li class="fragment" data-fragment-index="0">Un ambiente isolato, sicuro e scalabile per le vostre applicazioni</li>
			<li class="fragment" data-fragment-index="1">Basta problemi di dipendenze, pacchetti o altri punti di rottura nelle fasi di deply</li>
			<li class="fragment" data-fragment-index="2">Eseguire ogni applicazione nel suo container isolato, tante versioni di librerie o dipendenze</li>
			<li class="fragment" data-fragment-index="3">Automatizzare testing, integration, packaging...tutto si può scrivere in uno script (del VOSTRO linguaggio)</li>
			<li class="fragment" data-fragment-index="4">Per tutti i linguaggi e OS</li>
			<li class="fragment" data-fragment-index="5">Reazioni istantanee di stop/start/snapshot di un servizio, altro che VMs!</li>
			<li class="fragment" data-fragment-index="6">Più tempo per scrivere buon codice!</li>
		</ul>
	</div>
</section>

<section>
    <h2>Un container per l'amministratore</h2>
        <div style="text-align: left;">
        <p>Fuori dal container:</p>
            <ul>
                <li class="fragment" data-fragment-index="0">Logging</li>
                <li class="fragment" data-fragment-index="0">Remote access</li>
                <li class="fragment" data-fragment-index="0">Network configuration</li>
                <li class="fragment" data-fragment-index="0">Monitoring</li>
            </ul>
        </div>
</section>


<section>
	<h2>L'amministratore felice</h2>
	<div style="text-align: left;">
	Configure once... run anything
	<ul>
		<li class="fragment" data-fragment-index="0">Ogni distro/cloud/server</li>
		<li class="fragment" data-fragment-index="1">Un ciclo di vita efficente, replicabile e comodo da gestire</li>
		<li class="fragment" data-fragment-index="2">Codice migliore = meno lavoro di mantenimento</li>
		<li class="fragment" data-fragment-index="3">Eliminare risorse inutili e differenze tra ambienti di dev/test/prod</li>
		<li class="fragment" data-fragment-index="4">Continuous deployment and continuous integration systems</li>
		<li class="fragment" data-fragment-index="5">Un container si adatta ogni momento, le VMs sono per sempre</li>
	</ul>
</section>

<section>
  <section>
    <h2>Installare Docker</h2>
    <p>
    <img src="docker-img/install.jpg">
    </p>
  </section>

  <section>
    <h2>Installazione di Docker</h2>
    <h3>Obiettivi</h3>
    <p>
    Al termine dell'installazione saprete:
    </p>
    <ul>
      <li>Come installare Docker</li>
      <li>Quando utilizzare <code>sudo</code> nell'esecuzione dei comandi Docker</li>
    </ul>
  </section>

  <section>
    <h2>Installazione di Docker</h2>
    <p>Docker è facile da installare.</p>
    <p>
    Può essere installato su:
    </p>
    <ul>
      <li>Una grande varità di distribuzioni Linux</li>
      <li>OSX attraverso una macchina virtuale</li>
      <li>Microsoft Windows attraverso una macchina virtuale</li>
    </ul>
  </section>

  <section>
    <h2>Installazione di Docker in OSX e Microsoft Windows</h2>
    <p>Docker non gira nativamente in OSX e Microsoft Windows.</p>
    <p>
    Ci sono tre modi per installare Docker in OSX e Microsoft Windows:
    </p>
    <ul>
      <li class="fragment" data-fragment-index="0">Utilizzare Docker Mac o Docker Windows (raccomandato)</li>
      <li class="fragment" data-fragment-index="1">Utilizzare la Docker Toolbox (precdentemente raccomandato)</li>
      <li class="fragment" data-fragment-index="2">Installare tutto manualmente in una macchina virtuale (VirtualBox ecc.)</li>
    </ul>
  </section>

  <section>
    <h2>Lanciare Docker in OSX e Windows</h2>
    <p>Quando si esegue <code>docker version</code> da un terminale:</p>
    <ul>
      <li class="fragment" data-fragment-index="0">la CLI si connette al Docker Engine attraverso un socket standard,</li>
      <li class="fragment" data-fragment-index="1">il Docker Engine in realtà sta girando in una macchina virtuale,</li>
      <li class="fragment" data-fragment-index="2">... ma la CLI non lo sa e non le interessa,</li>
      <li class="fragment" data-fragment-index="3">la CLI invia una richiesta attraverso l'API REST,</li>
      <li class="fragment" data-fragment-index="4">il Docker Engine nella VM processa la richiesta,</li>
      <li class="fragment" data-fragment-index="5">la CLI riceve la risposta e la mostra nel terminale.</li>
    </ul>
    <p class="fragment" data-fragment-index="6">Tutte le comunicazioni con il Docker Engine avvengono attraverso l'API.</p>
    <p class="fragment" data-fragment-index="7">Questo consentirà anche l'utilizzo di Engine remoti esattamente come se fossero locali.</p>
  </section>
  
  <section>
    <h2>Installazione manuale ...</h2>
    <blockquote>WHY?</blockquote>
    <p>
      In ogni caso non è molto difficile la procedura comporta due step:
    </p>
    <ol>
      <li class="fragment" data-fragment-index="0">Installare un sistema per la virtualizzazione</li>
      <li class="fragment" data-fragment-index="1">Installare docker tramite un package manager</li>
    </ol>
  </section>
  
  <section>
    <h2>Utilizzare la Docker Toolbox</h2>
    <p>La Docker Toolbox installa i seguenti componenti:</p>
    <ul>
      <li class="fragment" data-fragment-index="0">VirtualBox + Boot2Docker VM image (Docker Engine)</li>
      <li class="fragment" data-fragment-index="1">Kitematic GUI</li>
      <li class="fragment" data-fragment-index="2">Docker CLI</li>
      <li class="fragment" data-fragment-index="3">Docker Machine\</li>
      <li class="fragment" data-fragment-index="4">Docker Compose</li>
      <li class="fragment" data-fragment-index="5">Una serie di utili wrapper</li>
    </ul>
  </section>

  <section>
    <h2>Boot2Docker ... WHAT'S BOOT2DOCKER???</h2>
    <p>E' una immagine VM molto piccola (~30MB).</p>
    <p>Funziona sulla maggio parte degli hypervisors e può essere lanciata direttamente anche dal metal.</p>
    <p>Boot2Docker non è una versione "lite" di Docker</p>
    <p>
    <img src="docker-img/boot2docker.png">
    </p>
  </section>

  <section>
    <h2>Docker OSX e Docker Windows</h2>
    <ul>
      <li class="fragment" data-fragment-index="0">Docker Mac e Docker Windows sono i prodotti più recenti</li>
      <li class="fragment" data-fragment-index="1">Consentono di far partire Docker senza VirtualBox</li>
      <li class="fragment" data-fragment-index="2">Sono installati come normali applicazioni (pensate a una cosa tipo QEMU ma più veloce)</li>
      <li class="fragment" data-fragment-index="3">Forniscono una migliore integrazione con le VPN enterprise</li>
      <li class="fragment" data-fragment-index="4">Supportano la condivisione del filesystem attraverso i volumi</li>
      <li class="fragment" data-fragment-index="5">la CLI riceve la risposta e la mostra nel terminale.</li>
    </ul>
    <p class="fragment" data-fragment-index="6">L'unico limite attuale è che può essere lanciata una sola istanza alla volta quindi 
    se si vuole creare un cluster su una sola macchina è necessario utilizzare Docker Toolbox.
    I due strumenti possono essere installati insieme coesistendo in pace e prosperità ;)</p>
  </section>
  
  <section>
    <h2>Take some SUDO with you!</h2>
    <p>
      <img src="docker-img/sudo-1.jpg"/>
    </p>
  </section>

  <section>
    <h2>Caveat importanti sulla sicurezza</h2>
    <p>L'utente <code>docker</code> è l'equivalente dell'utente <code>root</code></p>
    <p>Fornisce un accesso di livello <code>root</code> all'host</p>
    <p>E' necessario quindi proteggerl come si protegge l'utente<code>root</code></p>
    <p>Se date a qualcuno accesso all'API docker gli state dando accesso completo alla macchina</p>
    <p>Per questo il socket per controllare Docker è di default di proprietà del gruppo <code>docker</code>
    per evitrare accesso non autorizzato in macchine multi utente</p>
    <p>Se il vostro utente non è nel gruppo <code>docker</code> dovrete utilizzare <code>sudo</code> 
    davanti ad ogni comando es. <code>sudo docker version</code></p>
  </section>
</section>

<section>
  <section>
    <h2>I nostri primi containers</h2>
    <p>
    <img src="docker-img/firstcontainers.jpg">
    </p>
  </section>
  
  <section>
    <h2>I nostri primi containers</h2>
    <h3>Obiettivi</h3>
    <p>
    Al termine di questa parte del corso avrete:
    </p>
    <ul>
      <li>Visto Docker in azione.</li>
      <li>Avrete fatto partire i vostri primi containers.</li>
    </ul>
  </section>
  
  <section>
    <h2>Architettura di Docker</h2>
    <p>Docker è un'applicazione client-server.</p>
    <ul>
      <li class="fragment" data-fragment-index="0"><strong>Il Docker Engine (o "daemon")</strong>
        riceve e processa tutte le chiamate effettuate all'API
      </li>
      <li class="fragment" data-fragment-index="1"><strong>Il Docker client</strong>
        Parla con il demone Docker attraverso l'API Docker.
        Utilizzeremo principalmente la CLI embedded nel binario <code>docker</code>
      </li>
      <li class="fragment" data-fragment-index="2"><strong>Docker Hub Registry</strong>
        Collezione di immagini pubbliche.
        Il demone Docker parla con l'hub attraverso l'API del registry.
      </li>
    </ul>
  </section>

  <section>
    <h2>Hello World</h2>
    <p>
      Nel vostro ambiente Docker eseguite questo comando:
    </p>
    <pre>
      <code>$ docker run busybox echo hello world
           hello world</code>
    </pre>
  </section>

  <section>
    <h2>Il nostro primo container!</h2>
    <ul>
      <li class="fragment" data-fragment-index="0">Abbiamo utilizzato una delle immagini più piccole e semplici: <code>busybox</code></li>
      <li class="fragment" data-fragment-index="1"><code>busybox</code> viene di solito utilizzata per sistemi embedded (telefoni, router ecc.)</li>
      <li class="fragment" data-fragment-index="2">Abbiamo lanciato un solo processo e stampato <code>hello world</code></li>
    </ul>
  </section>

  <section>
    <h2>Un container più utile</h2>
    <p>
      Eseguiamo ora un container un po' più interessante:
    </p>
    <pre>
      <code>$ docker run -it ubuntu 
           root@04c0bb0a6c07:/#</code>
    </pre>
    <ul>
      <li class="fragment" data-fragment-index="0">Un container nuovo di zecca.</li>
      <li class="fragment" data-fragment-index="1">Esegue una versione minimale del sistema <code>ubuntu</code>.</li>
      <li class="fragment" data-fragment-index="2"><code>-it</code> è un'abbreviazione per <code>-i -t</code>.
        <ul>
          <li class="fragment" data-fragment-index="3"><code>-i</code> dice a Docker di connetterci alla stdin del container.</li>
          <li class="fragment" data-fragment-index="4"><code>-t</code> dice a Docker che vogliamo uno pseudo terminale.</li>
        </ul>
      </li>
    </ul>
  </section>

  <section>
    <h2>Facciamo qualcosa nel nostro container</h2>
    <p>
      Proviamo ad eseguire il comando <code>figlet</code> nel nostro container.
    </p>
    <pre>
      <code>
           root@04c0bb0a6c07:/# figlet hello
         bash: figlet: <b>command</b> not found
      </code>
    </pre>
    <p>
      Sembra che dobbiamo installare <code>figlet</code>.
    </p>
  </section>
  
  <section>
    <h2>Un'osservazione</h2>
    <p>
     Vediamo quanti pacchetti abbiamo installati nel nostro container:
    </p>
    <pre>
      <code>
           root@04c0bb0a6c07:/# dpkg -l | wc -l
           103
      </code>
    </pre>
    <ul>
      <li class="fragment" data-fragment-index="0"><code>dpkg -l</code> elenca tutti i pacchetti installati nel nostro container</li>
      <li class="fragment" data-fragment-index="1"><code>wc -l</code> li conta.</li>
      <li class="fragment" data-fragment-index="2">Se avete a disposizione una macchina Debian o Ubuntu potete fare un confronto.</li>
    </ul>
  </section>

  <section>
    <h2>Installare un package nei nostri container</h2>
    <p>
      Vogliamo <code>figlet</code>, quindi installiamocelo!
    </p>
    <pre>
      <code data-trim data-noescape>
root@04c0bb0a6c07:/# apt-get update
...
Fetched 1514 kB in 14s (103 kB/s)
Reading package lists... Done
root@04c0bb0a6c07:/# apt-get install figlet
Reading package lists... Done
...
      </code>
    </pre>
    <p>
      Tra un minuto <code>figlet</code> sarà installato!
    </p>
    <pre>
      <code data-trim>
 root@04c0bb0a6c07:/# figlet hello
 _          _ _       
| |__   ___| | | ___  
| '_ \ / _ \ | |/ _ \ 
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/ 
      </code>
    </pre>
  </section>

  <section>
    <h2>Uscire da un container</h2>
    <p>
      E' sufficiente uscire dalla shell come fareste da una qualsiasi shell
      (es. con <code>^D</code> o <code>exit</code>)
    </p>
    <pre>
      <code>
           root@04c0bb0a6c07:/# exit
      </code>
    </pre>
    <ul>
      <li class="fragment" data-fragment-index="0">Il nostro container è ora nello stato <i>stopped</i>.</li>
      <li class="fragment" data-fragment-index="1">Esiste ancora nel disco ma tutte le sue risorse di calcolo sono state rese disponibili.</li>
    </ul>
  </section>

  <section>
    <h2>Eseguire un altro container</h2>
    <p>
      Cosa succede se facciamo partire un nuovo container e cerchiamo di eseguirci <code>figlet</code>?
    </p>
    <pre>
      <code>
docker run -it ubuntu
root@b13c164401fb:/# figlet
bash: figlet: <b>command</b> not found
      </code>
    </pre>
    <ul>
      <li class="fragment" data-fragment-index="0">Abbiamo lanciato un nuovo container</li>
      <li class="fragment" data-fragment-index="1">Abbiamo utilizzato l'immagine base di Ubuntu e <code>figlet</code> non è installato.</li>
      <li class="fragment" data-fragment-index="2">A breve vedremo come preparare un'immagine customizzata che contenga <code>figlet</code></li>
    </ul>
  </section>
</section>


<section>
  <section>
    <h2>Background containers</h2>
    <p>
    <img src="docker-img/background-containers.jpg">
    </p>
  </section>

  <section>
    <h2>Background containers</h2>
    <h3>Obiettivi</h3>
    <p>
      I nostri primi container erano interattivi.
    </p>
    <p>
      Ora vedremo come:
    </p>
    <ul>
      <li>Eseguire un container non interattivo.</li>
      <li>Eseguire un container nel background.</li>
      <li>Elencare i container in esecuzione.</li>
      <li>Controllare i log dei container.</li>
      <li>Arrestare un container.</li>
      <li>Elencare i container arrestati.</li>
    </ul>
  </section>

  <section>
    <h2>Un container non interattivo</h2>
    <p>
      Eseguiremo un piccolo container personalizzato.
    </p>
    <p>
      Il suo unico task è quello di mostrare il tempo ogni secondo.
    </p>
    <pre>
      <code>
docker run jpetazzo/clock
Sun Oct 02 00:28:53 UTC 2016
Sun Oct 02 00:28:54 UTC 2016
Sun Oct 02 00:28:55 UTC 2016
...
      </code>
    </pre>
    <ul>
      <li class="fragment" data-fragment-index="0">Questo container continua la sua esecuzione in eterno!</li>
      <li class="fragment" data-fragment-index="1">Per arrestarlo digitate: <code>^C</code>.</li>
      <li class="fragment" data-fragment-index="2">Docker ha scaricato automaticamente l'immagine jpetazzo/clock.</li>
      <li class="fragment" data-fragment-index="3">Questa immagine è un'immagine utente creata dall'utente <code>jpetazzo</code>.</li>
      <li class="fragment" data-fragment-index="4">Parleremo più diffusamente di immagini utente (e altri tipi di immagine).</li>
    </ul>
  </section>

  <section>
    <h2>Eseguire un container in background</h2>
    <p>
      I container possono essere eseguiti in background attraverso il flag <code>-d</code> (daemon mode).
    </p>
    <pre>
      <code>
docker run -d jpetazzo/clock
47d677dcfba4277c6cc68fcaa51f932b544cab1a187c853b7d0caf4e8debe5ad
      </code>
    </pre>
    <ul>
      <li class="fragment" data-fragment-index="0">Non vediamo l'output del container.</li>
      <li class="fragment" data-fragment-index="1">Ma non c'è motivo di preoccuparsi, Docker lo fa per noi inserendolo nei log.</li>
      <li class="fragment" data-fragment-index="2">Docker ci fornisce l'ID del container.</li>
    </ul>
  </section>

  <section>
    <h2>Elencare i container in esecuzione</h2>
    <p>
      Come possiamo controllare se il nostro container è ancora in esecuzione?
    </p>
    <p>
       Il comando <code>docker ps</code>, in maniera speculare al comando <code>ps</code> in UNIX, elenca i processi in esecuzione.
    </p>
    <pre>
      <code>
docker ps 
CONTAINER ID  IMAGE           ...  CREATED        STATUS        ...
47d677dcfba4  jpetazzo/clock  ...  2 minutes ago  Up 2 minutes  ...
      </code>
    </pre>
    <p>Docker ci fornisce:</p>
    <ul>
      <li class="fragment" data-fragment-index="0">L'ID (troncato) del nostro container.</li>
      <li class="fragment" data-fragment-index="1">L'immagine utilizzata per eseguire il container.</li>
      <li class="fragment" data-fragment-index="2">L'uptime del nostro container.</li>
      <li class="fragment" data-fragment-index="3">Altre informazioni (COMMAND, PORTS, NAME) che spiegheremo più avanti.</li>
    </ul>
  </section>

  <section>
    <h2>Lanciamo un altro po' di container</h2>
    <p>
      Lanciate un altro po' di container
    </p>
    <pre>
      <code>
docker run -d jpetazzo/clock
57ad9bdfc06bb4407c47220cf59ce21585dce9a1298d7a67488359aeaea8ae2a
docker run -d jpetazzo/clock
068cc994ffd0190bbe025ba74e4c0771a5d8f14734af772ddee8dc1aaf20567d
      </code>
    </pre>
    <p>Controllate che <code>docker ps</code> elenchi tutti i container che avete eseguito.</p>
  </section>

  <section>
    <h2>Due flag utili per il comando <code>docker ps</code></h2>
    <p>
      Per visualizzare solamente l'ultimo container eseguito:
    </p>
    <pre> 
      <code>
$ docker ps -l
CONTAINER ID  IMAGE           ...  CREATED        STATUS        ...
068cc994ffd0  jpetazzo/clock  ...  2 minutes ago  Up 2 minutes  ...
      </code>
    </pre>
    <p>Per elencare solamente gli ID dei container:</p>
    <pre> 
      <code>
$ docker ps -q
068cc994ffd0
57ad9bdfc06b
47d677dcfba4
      </code>
    </pre>
    <p>Combinando i due flag si ottiene l'ID dell'ultimo container</p>
    <pre> 
      <code>
$ docker ps -lq
068cc994ffd0
      </code>
    </pre>
  </section>

  <section>
    <h2>Visualizzare i log di un container</h2>
    <p>
      Abbiamo detto che Docker logga tutto l'output di un container.
    </p>
    <p>
      Vediamo se è vero.
    </p>
    <pre> 
      <code>
$ docker logs 65ca
Sun Oct  2 09:07:52 UTC 2016
Sun Oct  2 09:07:53 UTC 2016
Sun Oct  2 09:07:54 UTC 2016
...
      </code>
    </pre>
    <ul>
      <li class="fragment" data-fragment-index="0">Abbiamo specificato un prefisso dll'ID completo del container</li>
      <li class="fragment" data-fragment-index="1">Naturalmente è possibile specificare l'intero ID</li>
      <li class="fragment" data-fragment-index="2">Il comando <code>logs</code> mostra tutti i log del container per intero
        (talvolta è un po' eccessivo quindi vediamo come risolvere questo problema.)
      </li>
    </ul>
  </section>

  <section>
    <h2>Visualizzare solamente la coda dei log (tail)</h2>
    <p>
    Per evitare di essere spammati con vagonate di pagine di log possiamo utilizzare l'opzione <code>--tail</code>:
    </p>
    <pre> 
      <code>
$ docker logs --tail 3 65ca
Sun Oct  2 09:09:27 UTC 2016
Sun Oct  2 09:09:28 UTC 2016
Sun Oct  2 09:09:29 UTC 2016
      </code>
    </pre>
    <ul>
      <li>Il parametro rappresenta il nomero di linee che vogliamo visualizzare.</li>
    </ul>
  </section>

  <section>
    <h2>Seguire i log in tempo reale</h2>
    <p>
    Esattamente come il comando UNIX <code>tail -f</code>, possiamo seguire i log del nostro container:
    </p>
    <pre> 
      <code>
$ docker logs --tail 1 --follow 65ca
Sun Oct  2 09:13:36 UTC 2016
Sun Oct  2 09:13:37 UTC 2016
Sun Oct  2 09:13:38 UTC 2016
Sun Oct  2 09:13:39 UTC 2016
^C
      </code>
    </pre>
    <ul>
      <li>Questo comando mostrerà l'ultima linea del file di log.</li>
      <li>Quindi continuerà a mostrare i log in tempo reale.</li>
      <li>Per uscire è sufficiente utilizzare <code>^C</code></li>
    </ul>
  </section>

  <section>
    <h2>Arrestare i container</h2>
    <p>
      Ci sono due vie per arrestare l'esecuzione del nostri container che girano in background: 
    </p>
    <ul>
      <li>Ucciderli con il comando <code>docker kill</code>.</li>
      <li>Arrestarli con il comando <code>docker stop</code>.</li>
    </ul>
    <p>
    Il primo arresta il container immediatamente utilizzando il segnale <code>KILL</code>.
    </p>
    <p>
      Il secondo è meno brutale. Invia un segnale <code>TERM</code> e attende 10 secondi, se dopo questo tempo il container
      non è ancora arrestato invia un segnale <code>KILL</code>.
    </p>
    <p>
      RICORDA: il segnale <code>KILL</code> non può essere intercettato e terminerà il container in modo forzoso.
    </p>
  </section>

  <section>
    <h2>Arrestiamo i nostri container</h2>
    <p>
      Arrestiamo uno dei nostri container:
    </p>
    <pre> 
      <code>
$ docker stop 65ca
65ca
      </code>
    </pre>
    <p>
      Questa operazione impiegherà 10 secondi:
    </p>
    <ul>
      <li>Docker invia il segnale <code>TERM</code>;</li>
      <li>il container non reagirà a questo segnale (è un semplice script di Shell senza alcuna logica per gestire i segnali),</li>
      <li>dopo 10 secondi visto che il container non si è arrestato Docker invierà il segnale <code>KILL</code>;</li>
      <li>questo termina il container.</li>
    </ul>
  </section>

  <section>
    <h2>Uccidiamo tutti gli altri container</h2>
    <p>
      Utilizziamo la forza bruta con gli altri due container rimasi:
    </p>
    <pre> 
      <code>
$ docker kill 0f5e c14a
0f5e
c14a
      </code>
    </pre>
    <p>
      Sia il comando <code>stop</code> che <code>kill</code> possono avere come argomenti più ID di container.
    </p>
    <p>
      I container indicati verranno terminati immediatamente senza attendere i 10 secondi.
    </p>
    <p>
      Verifichiamo che sia effettivamente così:
    </p>
    <pre> 
      <code>
$ docker ps
      </code>
    </pre>
  </section>

  <section>
    <h2>Elenchiamo anche i container arrestati</h2>
    <p>
    Possiamo elencare anche i container arrestati utilizzando l'opzione <code>-a (--all)</code>
    </p>
    <pre> 
      <code>
$ docker ps -a
CONTAINER ID        IMAGE               ...   CREATED             STATUS                                
c14a27fb3955        jpetazzo/clock      ...   18 minutes ago      Exited (137) Less than a second ago   
0f5ef5632456        jpetazzo/clock      ...   18 minutes ago      Exited (137) Less than a second ago   
65ca9dc7fc9f        jpetazzo/clock      ...   11 hours ago        Exited (137) Less than a second ago   
989976a9bece        ubuntu              ...   13 hours ago        Exited (0) 12 hours ago               
      </code>
    </pre>
  </section>
</section>

<section>
  <section>
    <h2>Far ripartire e "attaccarsi" ad un container</h2>
  </section>
  
  <section>
    <h2>Far ripartire e agganciarsi ad un container</h2>
    <h3>Obiettivi</h3>
    <p>  
      Abbiamo lanciato i container in foreground e in background.
    </p>
    <p>
      Ora vedremo come:
    </p>
    <ul>
      <li>Inviare un container in background.</li>
      <li>Agganciarsi ad un container che gira in background per riportarlo in foreground.</li>
      <li>Far ripartire un container arrestato.</li>
    </ul>
  </section>

  <section>
    <h2>Backgroud e Foreground</h2>
    <p>  
      La distinzione tra background e foreground è opinabile.
    </p>
    <p>
      Dal punto di vista di Docker tutti i container sono creati uguali.
    </p>
    <p>
     Tutti i container vengono eseguiti alla stessa maniera, sia che vi sia un client agganciato ad essi o meno. 
    </p>
    <p>
      E' sempre possibile sganciarsi da un container e poi riagganciarvisi.
    </p>
    <p>
      ANALOGIA: agganciarsi ad un container è come attaccare tastiera e schermo a un server fisico.
    </p>
  </section>

  <section>
    <h2>Sganciarsi da un container</h2>
    <ul>
      <li class="fragment" data-fragment-index="0">Se abbiamo fatto partire un container in modalità interattiva 
        ossia con l'opzione <code>-it</code> possiamo sganciarci da esso.
      </li>
      <li class="fragment" data-fragment-index="1">La sequenza di "sgancio" è <code>^P^Q</code></li>
      <li class="fragment" data-fragment-index="2">Altrimenti ci si può sganciare uccidnedo il client Docker
        (ma NON attraverso <code>^C</code>, pqerché in questo modo si invierebbe un <code>SIGINT</code> al container). 
      </li>
    </ul>
    <p class="fragment" data-fragment-index="3">Quindi cosa significa esattamente <code>-it</code></p>
    <ul>
      <li class="fragment" data-fragment-index="5"><code>-t</code> significa "alloca un terminale".</li>
      <li class="fragment" data-fragment-index="6"><code>-i</code> significa "connetti la stdin al terminale".</li>
    </ul>
  </section>

  <section>
    <h2>Sganciarsi da un container non interattivo</h2>
    <ul>
      <li class="fragment" data-fragment-index="0"><b>ATTENZIONE:</b> se il container non è stato lanviato con le opzoni <code>-it</code> ...
       <ul>
         <li class="fragment" data-fragment-index="1">Non ci si potrà sganciare da esso con la sequenza <code>^P^Q</code></li>
         <li class="fragment" data-fragment-index="2">L'utilizzo del <code>^C</code> farebbe proxare il comando al container e lo terminerebbe.</li>
       </ul> 
      </li>
      <li class="fragment" data-fragment-index="3">Ricordarsi: che è sempre possibile sganciarsi terminando il Docker Client.</li>
    </ul>
  </section>

  <section>
    <h2>Controllare l'output di un container</h2>
    <ul>
      <li><code>docker attach</code> va utilizzato nel caso in cui si intenda fornire input al container</li>
      <li>Se si vuole invece controllare solamente l'output di un container è meglio utilizzare <code>docker logs</code></li>
    </ul>
    <pre> 
      <code>
$ docker logs --tail 1 --follow <containerID>
      </code>
    </pre>
  </section>

  <section>
    <h2>Far ripartire un container</h2>
    <p>Quando un container è uscito si trova in stato di arresto.</p>
    <p>Per farlo ripartire è sufficiente utilizzare il comando <code>start</code></p>
    <pre> 
      <code>
$ docker start <yourContainerID> 
      </code>
    </pre>
    <p>Il container verra fatto ripartire con le stesse opzioni con cui era stato eseguito originariamente.</p>
    <p>Se si vuole interagire con esso ci si può riagganciare:</p>
    <pre> 
      <code>
$ docker attach <yourContainerID> 
      </code>
    </pre>
    <p>Utilizzare il comando <code>docker ps -a</code> per identificare l'ID di un precedente container <code>jpetazzo/clock</code>
    e fate alcune prove con questi comandi.</p>
  </section>

  <section>
    <h2>Agganciarsi ad una REPL</h2>
    <ul>
      <li class="fragment" data-fragment-index="0">REPL = Read, Eval, Print, Loop</li>
      <li class="fragment" data-fragment-index="1">Tipicamente una shell</li>
      <li class="fragment" data-fragment-index="2">Sintomo: esegui <code>docker attach</code> e non vedi nulla</li>
      <li class="fragment" data-fragment-index="3">La REPL non sa che ti sei agganciato e quindi non stampa nulla.</li>
      <li class="fragment" data-fragment-index="4">Provare con la combinazione <code>^L</code> o con il tasto <code>Enter</code></li>
    </ul>
  </section>
</section>

<section>
	<h2>Ma cos'è un Linux container?</h2>
	<p>
		<img src="docker-img/why-are-containers-lightwight.png">
	</p>
</section>

<section>
	<h2>Pro</h2>
	<div>
		<ul>
			<li class="fragment" data-fragment-index="0">Run everywhere</li>
			<ul class="fragment" data-fragment-index="0">
				<li>Non è importante la distribuzione</li>
				<li>Non è importante la versione del kernel</li>
			</ul>
			<li class="fragment" data-fragment-index="1">Run anything</li>
			<ul class="fragment" data-fragment-index="1">
				<li>Se può essere eseguito nell'host, può girare nel container</li>
				<li>Se può essere eseguito sul kernel Linux, si può!</li>
			</ul>
		</ul>
	</div>
</section>

<section>
	<h2>Dall'alto al basso</h2>
		<ul>
			<li class="fragment" data-fragment-index="0">High level: a lightweight VM</li>
			<ul class="fragment" data-fragment-index="0">
				<li>Proprio process space</li>
				<li>Propria network interface</li>
				<li>È anche root</li>
				<li>Il suo /sbin/init (diverso dell'host)</li>
				<li>&lt;&lt;machine container&gt;&gt;</li>
			</ul>
			<li class="fragment" data-fragment-index="1">Low level: chroot on steroids</li>
			<ul class="fragment" data-fragment-index="1">
				<li>Può anche <i>non </i>avere il suo /sbin/init</li>
				<li>Container = isolated processes</li>
				<li>Condivide il kernel dell'host</li>
                <li>No device emulation</li>
				<li>&lt;&lt;application container&gt;&gt;</li>
			</ul>
		</ul>
</section>

<section>
    <h2>Containers systems</h2>
    <div>
    <p><b>I soliti noti</b></p>
    <ul>
        <li class="fragment" data-fragment-index="0">Linux</li>
        <ul>
            <li class="fragment" data-fragment-index="0">OpenVZ</li>
            <li class="fragment" data-fragment-index="0">LXC</li>
            <li class="fragment" data-fragment-index="0">Libcontainer (Docker)</li>
        </ul>
        <li class="fragment" data-fragment-index="1">Others</li>
        <ul>
            <li class="fragment" data-fragment-index="1">Jail (FreeBSD)</li>
            <li class="fragment" data-fragment-index="1">Zone (Solaris)</li>
            <li class="fragment" data-fragment-index="1">App-V (Microsoft .NET)</li>
        </ul>
    </ul>
    </div>
</section>

<section>
    <h2>Performance</h2>
        <ul>
            <li class="fragment" data-fragment-index="0">I processi sono isolati, ma vengono eseguiti sull'host</li>
            <li class="fragment" data-fragment-index="1">CPU performance = native performance
            <li class="fragment" data-fragment-index="2">MEM performance = perdita di una micro % della performance rispetto all'host</li>
            <li class="fragment" data-fragment-index="3">Network performance = native performance, ma dipendono dalla distribuzione dei container</li>
        </ul>
</section>
<section>
    <h2>VMs vs Containers</h2>
        <p>
            <img src="docker-img/containers-vs-vms.png">
        </p>
</section>

<section>
	<h2>Come funziona un container Linux</h2>
	<div>
		<ul>
			<li class="fragment" data-fragment-index="0">Namespace: isolamento dei processi</li>
			<ul>
				<li class="fragment" data-fragment-index="0">PID</li>
				<li class="fragment" data-fragment-index="0">User</li>
				<li class="fragment" data-fragment-index="0">Network</li>
			</ul>
			<li class="fragment" data-fragment-index="1">Cgroups: Resources management</li>
			<li class="fragment" data-fragment-index="2">Copy-on-write Filesystem (AUFS)</li>
			<li class="fragment" data-fragment-index="3">Linux Capabilities</li>
			<li class="fragment" data-fragment-index="4">SElinux/Apparmor (stopdisablingselinux.com)</li>
            <li class="fragment" data-fragment-index="5">Read-only mount point<br>(/sys /proc/sys /proc/sysrq-trigger /proc/irq /proc/bus)</li>
		</ul>
	</div>
</section>

<section>
    <div>
    <h2>Isolation with namespace</h2>
    <ul>
        <li class="fragment" data-fragment-index="0">pid</li>
        <li class="fragment" data-fragment-index="0">mnt</li>
        <li class="fragment" data-fragment-index="0">net</li>
        <li class="fragment" data-fragment-index="0">uts</li>
        <li class="fragment" data-fragment-index="0">ipc</li>
        <li class="fragment" data-fragment-index="0">user</li>
    </ul>
</div>
</section>

<section>
    <div>
    <h2>Isolation with cgroups</h2>
        <ul>
            <li class="fragment" data-fragment-index="0">memory</li>
            <li class="fragment" data-fragment-index="0">cpu</li>
            <li class="fragment" data-fragment-index="0">blkio</li>
            <li class="fragment" data-fragment-index="0">devices</li>
        </ul>
     </div>
</section>

<section>
    <div>
    <h2>Copy-on-write storage</h2>
        <ul>
            <li class="fragment" data-fragment-index="0">union filesystem<br>(AUFS, overlayfs)</li>
            <li class="fragment" data-fragment-index="0">snapshot filesystem<br>(BTRFS, ZFS)</li>
            <li class="fragment" data-fragment-index="0">copy-on-write block devices<br>(snapshot con LVM o device-mapper)</li>
        </ul>
    </div>
</section>

<section>
    <h2>Containers do not contain</h2>
    <div style="text-align: left;"><p>"Docker is about running random code downloaded from the Internet and running it as root."</p></div>
    <ul>
        <li class="fragment" data-fragment-index="0">Eseguire processi in un container NON è sicuro come in una VMs/KVM </li>
        <li class="fragment" data-fragment-index="1">Scaricare immagini Docker casuali e lanciarle È COME eseguire codice casuale.</li>
    </ul>
</section>

<section>
    <div>
        <h2>Best Practices</h2>
        <ul>
            <li class="fragment" data-fragment-index="0">Drop privileges</li>
            <li class="fragment" data-fragment-index="1">Eseguire i servizi come non-root user</li>
            <li class="fragment" data-fragment-index="2">Trattare root nel container come root nell'host</li>
            <li class="fragment" data-fragment-index="3">Gestire le linux capabilities<br>(CAP_SYS_ADMIN)</li>
            <li class="fragment" data-fragment-index="4">Non eseguire codice inutile nel container</li>
            <li class="fragment" data-fragment-index="5">SElinux/Apparmor<br>(http://stopdisablingselinux.com)
</section>

<section>
    <h2>Immagini Docker</h2>
    <div>
	<p>
		<img src="docker-img/basics-of-docker-system.png">
	</p>
</section>

<section>
    <h2>Scrivere da run/commit</h2>
    <div style="text-align: left;">
    <ol style="text-align: left;">
            <li class="fragment" data-fragment-index="0">docker run ubuntu bash</li>
            <li class="fragment" data-fragment-index="0">apt-get install pacchetto1 lib1</li>
            <li class="fragment" data-fragment-index="0">docker commit &lt;containerid&gt; &gt;imagename&gt;</li>
            <li class="fragment" data-fragment-index="0">docker run &lt;imagename&gt; bash</li>
            <li class="fragment" data-fragment-index="0">git clone... \ pip install\ etc</li>
            <li class="fragment" data-fragment-index="0">docker commit &lt;containerid&gt; &lt;imagename&gt;</li>
            <li class="fragment" data-fragment-index="0">docker commit &lt;containerid&gt; &lt;imagename&gt;</li>
            <li class="fragment" data-fragment-index="0">docker tag &lt;imagename&gt; &lt;user/image&gt;</li>
            <li class="fragment" data-fragment-index="0">docker push &lt;user/image&gt;</li>
        </ol>
    </div>
</section>

<section>
    <h2>Scrivere un Dockerfile</h2>
    <pre>
        FROM debian:wheezy<br>
        RUN apt-get update<br>
        RUN apt-get -y install ruby ruby-dev build-essential git libopenssl-ruby libxslt-dev libxml2-dev<br>
        RUN useradd banana -u 1000 -s /bin/bash --no-create-home<br>
        <br>
        RUN gem install -n /usr/bin bundler<br>
        RUN gem install -n /usr/bin rake<br>
        <br>                                          
        WORKDIR /home/vidarh/<br>
        ENV HOME /home/vidarh<br>
        <br>                      
        VOLUME ["/home"]<br>
        USER banana<br>
        EXPOSE 8080<br>

    </pre>

</section>

<section>
    <div>
    <h2>Usare Docker Hub</h2>
    <p>Vantaggi:</p>
    <ul>
        <li class="fragment" data-fragment-index="0">Registro remoto per le immagini</li>
        <li class="fragment" data-fragment-index="0">Immagini ufficiali di docker/distro/app</li>
        <li class="fragment" data-fragment-index="0">Download sicuro</li>
        <li class="fragment" data-fragment-index="0">GitHub Account</li>
        <li class="fragment" data-fragment-index="0">Comodo punto di partenza</li>
    </ul>
</div>
</section>

<section>
	<h2>Applicazioni</h2>
	<p>
		<img src="docker-img/changes-and-updates.png">
	</p>
</section>

<section>
    <div>
    <h2>Lanciare un container</h2>
    <p>Docker run...</p>
    <ul>
        <li class="fragment" data-fragment-index="0">Singolo comando</li>
        <li class="fragment" data-fragment-index="0">Container in background</li>
        <li class="fragment" data-fragment-index="0">Gestione dei volumi</li>
        <li class="fragment" data-fragment-index="0">Velocissimo</li>
    </ul>
</div>
</section>

<section>
    <h2>Orchestration</h2>
    <ul>
        <li class="fragment" data-fragment-index="0">Linking container<br>container-a:container-b</li>
        <li class="fragment" data-fragment-index="0">Provisioning<br>salt, puppet, cloud ide, etc</li>
        <li class="fragment" data-fragment-index="0">Service discovery</li>
        <li class="fragment" data-fragment-index="0">Dns/hostname</li>
    </ul>
</section>

</section>

<section>
<section>
	<h2>Ecosystem Support</h2>
	<font style="font-size: 28px; line-height: 1.1em; ">
		<ul>
			<li class="fragment" data-fragment-index="0">Operating systems</li>
			<ul>
				<li class="fragment" data-fragment-index="0">Virtually any distribution with a 2.6.32+ kernel</li>
				<li class="fragment" data-fragment-index="0">CoreOS—Small core OS purpose built with Docker</li>
			</ul>
			<li class="fragment" data-fragment-index="1">OpenStack</li>
			<ul>
				<li class="fragment" data-fragment-index="1">Docker integration into NOVA (&amp; compatibility with Glance, Horizon, etc.) accepted for Havana release</li>
			</ul>
			<li class="fragment" data-fragment-index="2">Private PaaS</li>
			<ul>
				<li data-fragment-index="2" class="fragment">OpenShift, Solum (Rackspace, OpenStack), Other TBA</li>
			</ul>
			<li class="fragment" data-fragment-index="3">Public PaaS</li>
			<ul>
				<li data-fragment-index="3" class="fragment">Deis, Voxoz, Cocaine (Yandex), Baidu PaaS</li>
			</ul>
			<li data-fragment-index="4" class="fragment">Public IaaS</li>
			<ul>
				<li data-fragment-index="4" class="fragment">Native support in Rackspace, Digital Ocean,+++</li>
				<li data-fragment-index="4" class="fragment">AMI (or equivalent) available for AWS &amp; other</li>
			</ul>
			<li data-fragment-index="5" class="fragment">DevOps Tools</li>
			<ul>
				<li data-fragment-index="5" class="fragment">Integrations with Chef, Puppet, Jenkins, Travis, Salt, Ansible +++</li>
			</ul>
			<li data-fragment-index="6" class="fragment">Orchestration tools</li>
			<ul>
				<li data-fragment-index="6" class="fragment">Kubernetes, Mesos, Heat, ++</li>
				<li data-fragment-index="6" class="fragment">Shipyard &amp; others purpose built for Docker</li>
			</ul>
			<li data-fragment-index="7" class="fragment">Applications</li>
			<ul>
				<li data-fragment-index="7" class="fragment">1000’s of Dockerized applications available at index.docker.io</li>
			</ul>
		</ul>
	</font>
</section>

<section>
	<h2>Ecosystem (a colori!)</h2>
	<p>
		<img src="docker-img/docker-eco.png">
	</p>
</section>

<section>
    <h2>Senza dimenticare</h2>
</section>

<section>
    <h2>Windows server...</h2>
    <p>
        <img src="docker-img/docker-windows.png">
    </p>
</section>

<section>
	<h2>Want to Learn More?</h2>
	<ul>
		<li><a href="http://www.docker.io/">www.docker.io</a></li>
		<ul>
			<li>Documentation</li>
			<li>Getting started (tutorial, installation, guide, etc)</li>
			<li>Introductory <a href="http://www.docker.io/the-whole-story/">whitepaper</a></li>
		</ul>
		<li>Github: <a href="http://github.com/dotcloud/docker">dotcloud/docker</a></li>
		<li>IRC: freenode #docker</li>
		<li>Google Group: <a href="https://groups.google.com/forum/#!forum/docker-user">docker-user</a></li>
		<li>Twitter: <a href="http://twitter.com/docker">@docker</a></li>
		<li>Meetups: <a href="http://www.docker.io/meetups">www.docker.io/meetups</a></li>
	</ul>
</section>

</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				
				width: 1366,
				height: 768,
				margin: 0.1,
				minScale: 0.2,
				maxScale: 1.2,
	
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
